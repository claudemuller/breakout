<!doctype html>
<html lang="en">
<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Brix</title>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        const PADDLE_WIDTH = 100,
          PADDLE_THICKNESS = 10,
          PADDLE_DISTANCE_FROM_EDGE = 60;
        let canvas,
          canvasContext,
          ballX = 75,
          ballY = 75,
          ballSpeedX = 5,
          ballSpeedY = 7,
          paddleX = 400,
          mouseX,
          mouseY;

        window.addEventListener('load', function load() {
          canvas = document.getElementById('gameCanvas');
          canvasContext = canvas.getContext('2d');

          const framesPerSecond = 30;
          setInterval(updateAll, 1000/framesPerSecond);

          canvas.addEventListener('mousemove', updateMousePos);
        });

        function updateAll() {
          update();
          render();
        }

        function updateMousePos(event) {
          let rect = canvas.getBoundingClientRect(),
            root = document.documentElement;

          mouseX = event.clientX - rect.left - root.scrollLeft,
          mouseY = event.clientY - rect.top - root.scrollTop;

          paddleX = mouseX - PADDLE_WIDTH / 2;
        }

        function ballReset() {
          ballX = canvas.width / 2;
          ballY = canvas.height / 2;
        }

        function update() {
          const paddleTopEdgeY = canvas.height - PADDLE_DISTANCE_FROM_EDGE,
            paddleBottomEdgeY = paddleTopEdgeY + PADDLE_THICKNESS,
            paddleLeftEdgeX = paddleX,
            paddleRightEdgeX = paddleLeftEdgeX + PADDLE_WIDTH;

          ballX += ballSpeedX;
          ballY += ballSpeedY;

          if (ballX > canvas.width || ballX < 0) ballSpeedX *= -1;
          if (ballY < 0) ballSpeedY *= -1;
          if (ballY > canvas.height) ballReset();
          if (ballY > paddleTopEdgeY && ballY < paddleBottomEdgeY &&
            ballX > paddleLeftEdgeX && ballX < paddleRightEdgeX) {
            const centerOfPaddleX = paddleX + PADDLE_WIDTH / 2,
              ballDistFromPaddleCentreX = ballX - centerOfPaddleX;

            ballSpeedY *= -1;
            ballSpeedX = ballDistFromPaddleCentreX * 0.35;
          }
        }

        function render() {
          colourRect(0, 0, canvas.width, canvas.height, 'black');

          colourCircle(ballX, ballY, 10, 'white');

          colourRect(paddleX, canvas.height - PADDLE_DISTANCE_FROM_EDGE, PADDLE_WIDTH, PADDLE_THICKNESS, 'white');

          drawDebugInfo();
        }

        function drawDebugInfo() {
          const xThreshold = 40,
            yThreshold = 15;
          let x = mouseX,
            y = mouseY;

          if (mouseX > canvas.width - xThreshold) x = mouseX - xThreshold;
          if (mouseY < yThreshold) {
            y = mouseY + yThreshold;
            x = mouseX + yThreshold;
          }

          colourText(`${mouseX},${mouseY}`, x, y, 'yellow');
        }

        function colourRect(x, y, width, height, colour) {
          canvasContext.fillStyle = colour;
          canvasContext.fillRect(x, y, width, height);
        }

        function colourCircle(x, y, radius, colour) {
          canvasContext.fillStyle = colour;
          canvasContext.beginPath();
          canvasContext.arc(x, y, radius, 0, Math.PI * 2, true);
          canvasContext.fill();
        }

        function colourText(msg, x, y, colour) {
          canvasContext.fillStyle = colour;
          canvasContext.fillText(msg, x, y);
        }
    </script>
</body>
</html>